# -*- coding: utf-8 -*-
"""Malaria_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/dhirajpatel3470/Malaria_detection/blob/master/Malaria_detection.ipynb

**Malarial Detection**

Malaria is a life-threatening disease caused by parasites that are transmitted to people through the bites of infected female Anopheles mosquitoes. 

It is preventable and curable.
In 2018, there were an estimated 228 million cases of malaria worldwide.
The estimated number of malaria deaths stood at 405 000 in 2018. 

Model made for Save humans by detecting and deploying Image Cells that contain Malaria or not!

This Dataset is taken from the official NIH Website: https://ceb.nlm.nih.gov/repositories/malaria-datasets/ .
"""

from google.colab import drive
drive.mount('/content/drive')

"""**SetUps**"""

from keras.models import Sequential
from keras.layers import Conv2D
from keras.layers import MaxPooling2D
from keras.layers import Flatten
from keras.layers import Dense
from keras.layers import Dropout
import os
from tensorflow import keras
import tensorflow as tf
import h5py

"""**Archiitecture of CNN**"""

#initialing the cnn
classifier=Sequential()

#step-1 convolution
classifier.add(Conv2D(32, (3, 3),input_shape=(64,64,3),activation ='relu'))

# step 2. pooling
classifier.add(MaxPooling2D(pool_size = (2, 2)))

# Adding a second convolutional layer
classifier.add(Conv2D(32, (3, 3), activation = 'relu'))
classifier.add(MaxPooling2D(pool_size = (2, 2)))
classifier.add(Dropout(0.4))

# Step 3 - Flattening
classifier.add(Flatten())

# Step 4 - Full connection
classifier.add(Dense(units = 128, activation = 'relu'))
classifier.add(Dropout(0.4))
classifier.add(Dense(units = 1, activation = 'sigmoid'))

# Compiling the CNN
classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

# Part 2 - Fitting the CNN to the images

from keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(rescale = 1./255,
                                   shear_range = 0.2,
                                   zoom_range = 0.2,
                                   horizontal_flip = True)

test_datagen = ImageDataGenerator(rescale = 1./255)

training_set = train_datagen.flow_from_directory('/content/drive/My Drive/data_Malaria/train',
                                                 target_size = (64, 64),
                                                 batch_size = 32,
                                                 class_mode = 'binary')

val_set = test_datagen.flow_from_directory('/content/drive/My Drive/data_Malaria/val',
                                            target_size = (64, 64),
                                            batch_size = 32,
                                            class_mode = 'binary')

#Infected
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
img = mpimg.imread('/content/drive/My Drive/data_Malaria/train/Infected/Infected_10001.png')
imgplot = plt.imshow(img)

#Uninfected
img = mpimg.imread('/content/drive/My Drive/data_Malaria/test/Uninfected/Uninfected_2757.png')
imgplot = plt.imshow(img)

"""**checkpoint**"""

from keras.callbacks import ModelCheckpoint
filepath="weights.best.h5"
checkpoint=ModelCheckpoint(filepath,monitor='val_accuracy',verbose=1,save_best_only=True,mode='max')
callbacks_list=[checkpoint]

"""**Fit the model**"""

history=classifier.fit_generator(training_set,
                         steps_per_epoch = 16534//32,
                         epochs =20,
                         validation_data = val_set,
                         validation_steps = 5512//32,
                         callbacks=callbacks_list,shuffle=True)

"""**Ploting accuracy curve and loss curve**"""

import matplotlib.pyplot as plt
# Plot training & validation accuracy values
plt.plot(history.history['acc'])
plt.plot(history.history['val_acc'])
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'val'], loc='upper left')
plt.show()

# Plot training & validation loss values
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'val'], loc='upper left')
plt.show()


#saving model
classifier.save('malaria_classifier.h5')

from keras.models import load_model

from keras.preprocessing.image import ImageDataGenerator
test_datagen = ImageDataGenerator(rescale = 1./255)
new_model=load_model('malaria_classifier.h5')

test_set = test_datagen.flow_from_directory('/content/drive/My Drive/data_Malaria/test',
                                            target_size = (64, 64),
                                            batch_size = 32,
                                            class_mode = 'binary')

"""**Evaluation on test test**"""

result=new_model.evaluate_generator(test_set,32)
result

print(test_set.class_indices)
print(type(test_labels))
test_labels=np.array(test_labels)
type(test_labels)

from sklearn.metrics import roc_curve, auc
n_classes=2
fpr = dict()
tpr = dict()
roc_auc = dict()

fpr, tpr, _ = roc_curve(test_labels, y_pred)
roc_auc = auc(fpr, tpr)

# Plot of a ROC curve for a specific class

plt.figure()
plt.plot(fpr, tpr, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], 'k--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()